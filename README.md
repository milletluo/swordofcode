# swordofcode  剑指offer
## 01AssignmentOperator赋值运算符
1. 返回值类型为该类型的引用，以允许连续赋值
2. 传入的参数类型为常量引用，避免调用复制构造函数造成无谓消耗
3. 释放实例自身已有的内存
4. 判断是否是同一个实例
5. 考虑异常安全性
## 02Singleton实现单例模式
1. 私有构造函数
2. 懒汉式：静态成员变量，类外初始化，静态方法实例化对象，并返回
3. 饿汉式：静态局部变量在第一次使用时初始化，并不会销毁直到程序退出
## 03FindInSortedMatrix有序二维数组中查找
1. 从数组的角上（例如右上角）开始查找，直接定位或剔除一列或一行
## 04ReplaceSpaces替换空格
1. 先遍历一次获取空格数，由此计算出替换后的数组总长
2. 从数组尾部开始向前复制和替换
## 05PrintListReversed从尾到头打印列表
1. 利用“后进先出”的栈
2. 递归：每次访问一个节点时先打印其后面的节点，再打印自身
## 06ConstructBinaryTrees重建二叉树
1. 二叉树的前序遍历中，第一个节点总是树的根节点
2. 中序遍历中，左树在根节点的左边，右树在右边
3. 利用前序遍历定位根节点，在中序遍历中找到根节点，获取左右子树的长度，递归处理左子树和右子树
## 07QueueWithTwoStacks用两个栈实现队列
1. 取出元素时，如果stack2为空，先将stack1中元素都压入stack2，再从stack2顶部取出；如果stack2不为空，直接从stack2顶部取出
## 08MinNumberInRArray旋转数组的最小数字
1. 理解旋转数组，把递增排序数组前面若干个数搬到尾部
2. 由于数组一定程度是排序的，使用二分查找法：判断中间位置元素是处于前半递增数组还是后半递增数组，更新两端节点的位置
3. 考虑数组中元素相等的情况，只能用顺序查找
## 09Fibonacci斐波那契数列
1. 递归是逆序计算f(n)=f(n-1)+f(n-2)，重复计算多，效率太低
2. 利用for循环，正序计算到第n个数
3. 跳n级台阶的跳法问题也可抽象成斐波那契数列问题
## 10Numberof1InBinary二进制中1的个数
1. 最右位与1做位与运算，再右移一位（比除以2效率高）
2. 考虑输入负数，不右移输入数字，而是左移判断标志
3. 把一个整数减1，再和原整数做位与运算，会把该整数最右边一个1变成0，左边的保持不变。有多少个1就可以做多少次这种操作，直到最后与完的结果为0.
## 11Power数值的整数次方
1. 考虑输入指数为0或负数，先对指数取绝对值，在将结果求倒数（注意不能对0求倒数）
2. 判断小数（float和double）不能用==，要判断差的绝对值小于精度，比如0.0000001
3. 对求正整数次方进行优化，例如16次方=8次方*8次方，递归，注意奇偶
## 12Print1ToMaxOfNDigits打印1到最大的n位数
1. 考虑大数问题，用字符串表示数字，模拟加法、进位和打印
2. 递归实现全排列解决
## 13DeleteNodeInList在O(1)时间删除链表节点
1. 把下一个节点的内容复制到待删除节点，删除下一个节点即可
2. 如果待删除节点是尾部节点，则仍得从头遍历到该节点，然后删除
## 14ReorderOddEven调整数组顺序使奇数位于偶数前面
1. 类似于快速排序法，维护两个指针，一个指向头部的偶数，一个指向尾部的奇数，交换。直到相遇。
## 15KthNodeFromEnd链表中倒数第k个节点
1. 维护两个指针，第一个指针从头开始先走k-1步，然后第二个指针从头出发一起走，直到第一个指针走到链表尾，第二个指针即所求
2. 考虑链表为空，考虑链表长度不足k，考虑k=0
## 16ReverseList反转链表
1. 维护三个指针h、i、j，将i的下一个节点指向h，然后滚动后移
2. 考虑链表为空，链表只有一个节点，返回原链表的尾节点作为反转后的头结点
## 17MergeSortedLists合并两个排序的链表
1. 递归：将两个链表中值较小的头节点链接到已合并链表的尾部
2. 当一个链表为空时，直接将另一个链表链接到合并链表的尾部
## 18SubstructureInTree树的子结构
1. 递归：在A树中遍历查找B树的根节点，找到后再递归判断以该节点为根节点的子树和B树结构是否相同
2. 注意递归的退出条件，避免访问空指针
## 19MirrorOfBinaryTree二叉树的镜像
1. 递归：交换根节点下的叶子节点
2. 递归退出条件是根节点为空或左右叶子节点均为空
## 20PrintMatrix顺时针打印矩阵
1. 循环继续的条件：`columns>startX*2 && rows>startY*2`
2. 分析打印每一行、每一列时的前提条件、边界条件
## 21MinInStack包含min函数的栈
1. 维护一辅助栈，栈顶为最小值。数据栈每次压入数据时，与辅助栈比较，如果大于辅助栈栈顶，则继续压入一次辅助栈顶的最小值；如果小于，则压入该更小值
2. 数据栈弹出数据时，辅助栈也一起弹出顶部数据，以保持栈顶一直是对应的最小值
## 22StackPushPopOrder栈的压入、弹出序列
1. 维护一辅助栈，如果下一个弹出的数x是辅助栈栈顶，直接弹出；如果不在栈顶，尝试从压入序列中按顺序压入数据，直到压入到栈顶的数据等于x，弹出x；如果压入序列中所有的数据都压入栈了还没找到x,则弹出序列不匹配
## 23PrintTreeFromTopToBottom从上往下打印二叉树
1. 利用队列实现广度优先遍历
2. 先打印出根节点，将其子节点放入队列；从队列首取出一节点打印，将该节点的子节点（如果有）放入队列尾，重复操作
## 24SquenceOfBST二叉搜索树的后序遍历序列
1. 后序遍历得到的序列中，最后一个数字是树的根节点；前面的第一部分是左子树，均小于根节点，第二部分是右子树，均大于根节点
2. 先找到根节点，依据大小关系将序列拆成左、右子树序列，再递归处理这两个子序列
